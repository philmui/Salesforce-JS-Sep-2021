Schedule :
    Commence    : t:00 hours
    Tea break   : t:00 + 1:30 hours (15 mins)
    Lunch break : t:00 + 3:30 hours (1 hour)
    Tea break   : t:00 + 6:00 hours (15 mins)
    End         : t:00 + 7:30 hours


About You:
    Total Experience
    Primary skillset
    Experience in JavaScript

Why JS?

1. Data Types
    number, string, boolean, object, function, undefined

2. Programming constructs
    var, if else, switch case, while, for, try catch finally, throw, function

3. APIs
    Date, Math, Array, RegEx, Object, Error, setTimeout, clearTimeout, setInterval, clearInterval

ES6 / ECMAScript 6 (2015)

Loosely Typed
Dynamic
Functional 
    functions are first class citizens
        functions can be treated data (object)
            assign functions to variables
            pass functions as arguments
            return functions as return values from functions
    functions are called as callable objects
    functions are variadic by default


$(domNode)
$([domNode, domNode, domNode])
$('#logo-events')
$(jQueryObj)
$(fn)

sum() //=> 0
sum(10) //=> 10
sum(10,20) //=> 30
sum(10,20,30,40,50) //=> 150
sum(10,20,30,"40",50) //=> 150
sum(10,20,30,"abc",50) //=> 100
sum([10,20,30],[40,50]) //=> 150
sum([10,20,30],["40",50]) //=> 150
sum([10,20,30],["abc",50]) //=> 100
sum([10,[20,30]],["abc",50]) //=> 100
sum(function(){ return 10;}, function(){ return 20;}) // => 30
sum(function(){ return [10,[20,30]];},function(){ return ["abc",50]; } ) //=> 100
sum([function(){ return [10,[20,30]];},function(){ return ["abc",50]; } ]) //=> 100


Two implicit values available in a function
    - arguments
        array like object populated with all the argument values passed to the function
            arguments.length
            arguments[0]
            arguments[1]
            etc
    - this

    It DOES NOT matter where the function is OR who owns the function
    What matters is the HOW the function is invoked

    Function Invocation Patterns 
        1. When a function is invoked as a method of an object (obj)
                this => obj
        2. When invoked as a function
                this => global scope (window in the browser)

        3. Using the 'call' method of the function

        4. Using the 'apply' method of the function

        5. As an Immediately Invoked Function Expression (IIFE)

        6. Using the 'new' keyword (constructor function)
            this => new object
            this => returned by default

        
        
    Create an object and assign it to a variable called 'spinner'
    The object must have two methods (increment, decrement)

    var spinner = /*.....*/
    spinner.increment() //=> 1
    spinner.increment() //=> 2
    spinner.increment() //=> 3
    spinner.increment() //=> 4

    spinner.decrement() //=> 3
    spinner.decrement() //=> 2
    spinner.decrement() //=> 1
    spinner.decrement() //=> 0
    spinner.decrement() //=> -1

    IMPORTANT: The outcome of 'increment' & 'decrement' methods SHOULD NOT be able to be influenced from outside the object

    The following SHOULD NOT be possible
    spinner.counter = 10000
    spinner.increment() // SHOULD not return 10001

    OR

    counter = 10000
    spinner.increment() // SHOULD not return 10001

Pure Functions
    Functions with no side effects
    The invocation of the function can be replaced with the result of the function without affecting final outcome.

    Examples of Non-pure function

        /* ****************
            function add(x,y){
                console.log('processing ', x , ' and ', y); //=> side effect
                return x + y;
            }

        ***************** */

         /* ****************
            var z = 100
            function add(x,y){
                return x + y + z;
            }

        ***************** */


Day-01 Assignment
//Assignment
//Generalize the memoize function so that it can memoize 
//functions that take more than one argument.

//The following should work
/* 
var add = memoize(function(x,y){
    return x + y;
}) 
*/